# 1. How do we handle addresses in stateful arrays? Maybe transform it to an
# equivalent scalar form?

# 2. Setup some benchmarking infrastructure to turn on and off each optimization.

# 3. Maybe the full spec doesn't compile (or doesn't compile within a timeout).
# But some modification to the full spec causes it to compile (e.g., deleting a
# line of code).  Then we can see if we can take the modified spec's compiled
# output and "patch" it to get the full spec's compiled output.

# 4. Automatic conversion of Domino programs to spec files

# 5. Proofs of soundness and completeness of our optimizations

# 6. Try adding structure constraints as in https://homes.cs.washington.edu/~luisceze/publications/synapse-popl16.pdf
# This is similar to Xiangyu's idea as well.
# The idea is that when we search a 5*5 grid, we don't search 4*4 sub-grids (which have already been searched)
# Again, we can prove the soundness of these optimizations using the tool in 5.
# Borrowing from Synapse, structure constraints are constraints on the holes alone.
# Essentially they prune portions of the search space because they have already been searched.

# Structure constraints don't have to be perfect. They might prune only a small amount because they haven't be fully exploited
# (or the programmer was lazy to specify them completely).
# However, the key requirement is that they don't prune *too much* because that would violate completeness/optimality.
# It's probably impossible to have no redundant searches. Structure constraints decrease the number of redundant searches,
# but they should not prune out non-redundant searches.

The goal of the tool in 5 is to ensure that does not happen.

I am wondering if structure constraints are easier to specify if we increase the size of the grid more gradually, i.e.,
from 2*2 to 2*3 to 3*3 instead of 2*2 to 3*3 in one jump. I am not sure.
